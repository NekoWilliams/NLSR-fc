/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2025,  The University of Memphis,
 *                           Regents of the University of California,
 *                           Arizona Board of Regents.
 *
 * This file is part of NLSR (Named-data Link State Routing).
 * See AUTHORS.md for complete list of NLSR authors and contributors.
 *
 * NLSR is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NLSR is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NLSR, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "lsa/name-lsa.hpp"
#include "name-prefix-list.hpp"

#include "ndn-cxx/encoding/buffer-stream.hpp"

#include "tests/boost-test.hpp"

namespace nlsr::tests {

BOOST_AUTO_TEST_SUITE(TestNameLsa)

const uint8_t NAME_LSA1[] = {
  0x89, 0x4F, //name lsa
  0x80, 0x23, // lsa
  0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31, // router name (router1)
  0x82, 0x01, 0x0C, // sequence number (12)
  0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34,
  0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, // expiration time
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x31, // name (name1)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, // name (name2)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
};

const uint8_t NAME_LSA_EXTRA_NAME[] = {
  0x89, 0x64, //name lsa
  0x80, 0x23, // lsa
  0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31, // router name (router1)
  0x82, 0x01, 0x0C, // sequence number (12)
  0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34,
  0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, // expiration time
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x31, // name (name1)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, // name (name2)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, // name (name3)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
};

const uint8_t NAME_LSA_DIFF_SEQ[] = {
  0x89, 0x64, //name lsa
  0x80, 0x23, // lsa
  0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31, // router name (router1)
  0x82, 0x01, 0x0E, // sequence number (12)
  0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34,
  0x3A, 0x31, 0x33, 0x3A, 0x33, 0x34, // expiration time
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x31, // name (name1)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, // name (name2)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, // name (name3)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
};

const uint8_t NAME_LSA_DIFF_TS[] = {
  0x89, 0x64, //name lsa
  0x80, 0x23, // lsa
  0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31, // router name (router1)
  0x82, 0x01, 0x0E, // sequence number (12)
  0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34,
  0x3A, 0x31, 0x33, 0x3A, 0x34, 0x34, // expiration time (10s higher)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x31, // name (name1)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, // name (name2)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, // name (name3)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
};

const uint8_t NAME_LSA_DIFF_COST[] = {
  0x89, 0x64, //name lsa
  0x80, 0x23, // lsa
  0x07, 0x09, 0x08, 0x07, 0x72, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x31, // router name (router1)
  0x82, 0x01, 0x0E, // sequence number (12)
  0x8B, 0x13, 0x32, 0x30, 0x32, 0x30, 0x2D, 0x30, 0x33, 0x2D, 0x32, 0x36, 0x20, 0x30, 0x34,
  0x3A, 0x31, 0x33, 0x3A, 0x34, 0x34, // expiration time (10s higher)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x31, // name (name1)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x32, // name (name2)
  0x8C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (0)
  0x92, 0x13, // prefix info
  0x07, 0x07, 0x08, 0x05, 0x6E, 0x61, 0x6D, 0x65, 0x33, // name (name3)
  0x8C, 0x08, 0x40, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // cost (10)
};

BOOST_AUTO_TEST_CASE(Basic)
{
  ndn::Name s1{"name1"};
  ndn::Name s2{"name2"};
  NamePrefixList npl1{s1, s2};

  auto testTimePoint = ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196014943));

  // 3rd argument is seqNo
  NameLsa nlsa1("router1", 12, testTimePoint, npl1);
  NameLsa nlsa2("router2", 12, testTimePoint, npl1);

  BOOST_CHECK_EQUAL(nlsa1.getType(), Lsa::Type::NAME);
  BOOST_CHECK(nlsa1.getExpirationTimePoint() == nlsa2.getExpirationTimePoint());

  auto wire = nlsa1.wireEncode();
  BOOST_TEST(wire == NAME_LSA1, boost::test_tools::per_element());

  nlsa1.addName(PrefixInfo(ndn::Name("name3"), 0));
  wire = nlsa1.wireEncode();
  BOOST_TEST(wire == NAME_LSA_EXTRA_NAME, boost::test_tools::per_element());

  nlsa1.setSeqNo(14);
  wire = nlsa1.wireEncode();
  BOOST_TEST(wire == NAME_LSA_DIFF_SEQ, boost::test_tools::per_element());

  testTimePoint =
    ndn::time::fromUnixTimestamp(ndn::time::milliseconds(1585196024993));
  nlsa1.setExpirationTimePoint(testTimePoint);
  wire = nlsa1.wireEncode();
  BOOST_TEST(wire == NAME_LSA_DIFF_TS, boost::test_tools::per_element());

  nlsa1.addName(PrefixInfo(ndn::Name("name3"), 10));
  wire = nlsa1.wireEncode();
  BOOST_TEST(wire == NAME_LSA_DIFF_COST, boost::test_tools::per_element());
  // Not testing router name as not sure if that will ever change once set
}

BOOST_AUTO_TEST_CASE(InitializeFromContent)
{
  auto testTimePoint = ndn::time::system_clock::now();
  ndn::Name s1{"name1"};
  ndn::Name s2{"name2"};
  NamePrefixList npl1{s1, s2};

  NameLsa nlsa1("router1", 1, testTimePoint, npl1);
  NameLsa nlsa2(nlsa1.wireEncode());
  BOOST_CHECK_EQUAL(nlsa1.wireEncode(), nlsa2.wireEncode());
}

BOOST_AUTO_TEST_CASE(OperatorEquals)
{
  PrefixInfo name1 = PrefixInfo(ndn::Name("/ndn/test/name1"), 0);
  PrefixInfo name2 = PrefixInfo(ndn::Name("/ndn/test/name2"), 0);
  PrefixInfo name3 = PrefixInfo(ndn::Name("/ndn/some/other/name1"), 0);
  PrefixInfo name4 = PrefixInfo(ndn::Name("/ndn/some/other/name1"), 1);

  NameLsa lsa1;
  lsa1.addName(name1);
  lsa1.addName(name2);
  lsa1.addName(name3);

  NameLsa lsa2;
  lsa2.addName(name1);
  lsa2.addName(name2);
  BOOST_CHECK_NE(lsa1, lsa2);

  lsa2.addName(name3);
  BOOST_CHECK_EQUAL(lsa1, lsa2);

  NameLsa lsa3;
  lsa3.addName(name1);
  lsa3.addName(name2);
  lsa3.addName(name4);
  BOOST_CHECK_NE(lsa2, lsa3);

  NameLsa lsa4;
  lsa4.addName(name1);
  lsa4.addName(name2);
  lsa4.addName(name4);
  BOOST_CHECK_EQUAL(lsa3, lsa4);
}

BOOST_AUTO_TEST_CASE(Update)
{
  NameLsa knownNameLsa;
  knownNameLsa.m_originRouter = ndn::Name("/yoursunny/_/%C1.Router/dal");
  knownNameLsa.m_seqNo = 2683;
  knownNameLsa.setExpirationTimePoint(ndn::time::system_clock::now() + 3561_ms);
  knownNameLsa.addName(PrefixInfo(ndn::Name("/yoursunny/_/dal"), 0));
  knownNameLsa.addName(PrefixInfo(ndn::Name("/ndn"), 0));

  auto rcvdLsa = std::make_shared<NameLsa>();
  rcvdLsa->m_originRouter = ndn::Name("/yoursunny/_/%C1.Router/dal");
  rcvdLsa->m_seqNo = 2684;
  rcvdLsa->setExpirationTimePoint(ndn::time::system_clock::now() + 3600_ms);

  auto nlsa = std::static_pointer_cast<NameLsa>(rcvdLsa);
  nlsa->addName(PrefixInfo(ndn::Name("/ndn"), 0));
  nlsa->addName(PrefixInfo(ndn::Name("/yoursunny/_/dal"), 0));
  PrefixInfo addedName1 = PrefixInfo(ndn::Name("/yoursunny/video/ndn-dpdk_acmicn20_20200917"), 0);
  PrefixInfo addedName2 = PrefixInfo(ndn::Name("/yoursunny/pushups"), 0);
  nlsa->addName(addedName1);
  nlsa->addName(addedName2);

  auto [updated, namesToAdd, namesToRemove] = knownNameLsa.update(rcvdLsa);

  BOOST_CHECK_EQUAL(updated, true);
  BOOST_CHECK_EQUAL(namesToAdd.size(), 2);
  BOOST_CHECK_EQUAL(namesToRemove.size(), 0);
  auto it = std::find(namesToAdd.begin(), namesToAdd.end(), addedName1);
  BOOST_CHECK(it != namesToAdd.end());
  it = std::find(namesToAdd.begin(), namesToAdd.end(), addedName2);
  BOOST_CHECK(it != namesToAdd.end());
}

BOOST_AUTO_TEST_SUITE_END()

} // namespace nlsr::tests
